Objects are contained in Blocks
Blocks are referenced by Linkages and contained in Chunks
Linkages are contained in Heaps

====== BLOCKS ======

There are several states a Block can be in:
    Active
    Inactive Full
    Inactive Empty Enough
    Inactive Empty

The A state can only be reached from the IEE and IE states.
The IF state can only be reached from the A state.
The IEE state can only be reached from the IF state.
The IE state can only be reached from the IEE state.

Blocks respond to the events `hook_linkage_informs_block_of_allocation_request` and `hook_client_informs_block_of_deallocation_request`.
A block in IF-state will produce events of type `hook_block_informs_linkage_of_empty_enough_state`.
A block in IEE-state will produce events of type `hook_block_informs_linkage_of_empty_state`.

Blocks respond to the events `hook_linkage_informs_block_of_format_request` and `hook_heap_informs_block_of_reassignment`

====== LINKAGES ======

There are several types of Linkage:
    LocalAllocation (LAL)
    LocalReclamation (LRL)
    RegionalReclamation (RRL)

All Linkage types will produce the events `hook_linkage_informs_heap_of_surplus_block` and `hook_linkage_informs_heap_of_evacuating_block`.

LALs are always thread-local.
They are always sized linkages.
They respond to the events `hook_heap_informs_linkage_of_allocation_request`, `hook_block_informs_linkage_of_empty_enough_state`, and `hook_block_informs_linkage_of_empty_state`.
An LAL will produce events of types `hook_linkage_informs_block_of_allocation_request` and `hook_linkage_informs_heap_of_block_request`.

LRLs are always thread-local.
They are always unsized linkages.
They respond to the events `hook_heap_informs_linkage_of_block_request`, `hook_heap_informs_linkage_of_migrating_block`.
An LRL will produce no events other than the all-Linkage event types.

RRLs are never thread-local.
They may be unsized or sized linkages.
They respond to the events `hook_heap_informs_linkage_of_block_request` and `hook_heap_informs_linkage_of_migrating_block`.
If sized, they respond to the events `hook_block_informs_linkage_of_empty_enough_state` and `hook_block_informs_linkage_of_empty_state`.
An RRL will produce no events other than the all-Linkage event types.

====== HEAPS ======

There are several types of heap:
    Local (LH)
    Regional (RH)
    Global (GH)

LHs are thread-local.
They respond to the events `hook_linkage_informs_heap_of_surplus_block`, `hook_linkage_informs_heap_of_evacuating_block`, `hook_linkage_informs_heap_of_block_request` and `hook_client_informs_heap_of_allocation_request`.
They produce events of types `hook_heap_informs_heap_of_surplus_block`, `hook_heap_informs_heap_of_evacuating_block`, `hook_heap_informs_heap_of_block_request`, and `hook_heap_informs_linkage_of_allocation_request`.

RHs are reference-counted on a per-thread basis. When all references to them are lost, they are evacuated and destroyed.
They respond to the events `hook_linkage_informs_heap_of_surplus_block`, `hook_linkage_informs_heap_of_evacuating_block`, `hook_heap_informs_heap_of_surplus_block`, `hook_heap_informs_heap_of_evacuating_block`, and `hook_heap_informs_heap_of_block_request`.
They produce events of types `hook_heap_informs_heap_of_surplus_block`, `hook_heap_informs_heap_of_evacuating_block`, and `hook_heap_informs_heap_of_block_request`.

GHs are global; they are destroyed automatically on process-death or on explicit destruction.
They respond to the event `hook_heap_informs_heap_of_block_request`.
They produce no events.

====== ENTRY POINTS into different systems ======

    __vnza_malloc

the client application calls __vnza_malloc(size: usize) -> void *
__vnza_malloc will find the local LH and invoke it with the event `hook_client_informs_heap_of_allocation_request`.
    if the invocation is successful, the resulting object is returned
otherwise, a panic should occur

    LH hook_client_informs_heap_of_allocation_request

The LH will find the appropriately sized LAL and invoke `hook_heap_informs_linkage_of_allocation_request`.
The LAL will invoke `hook_linkage_informs_block_of_allocation_request` on the A-state block.
    if the invocation is successful, the result is returned
otherwise, the LAL will first try to perform an in-linkage IE(E) -> A swap.
    if the invocation is successful, `hook_linkage_informs_block_of_allocation_request` is called on the new A-State block, and the result is returned.
otherwise, the LAL will inform the LH that the operation failed.
The LH will then invoke `hook_heap_informs_linkage_of_block_request` on the LRL.
    if the invocation is successful, the resulting block is
        1. formatted
        2. moved to the appropriate LAL
    at which point the LAL is reinvoked with `hook_heap_informs_linkage_of_allocation_request`
        in this situation, this operation is guaranteed successful, and the result is returned.
otherwise, the LRL will tell the LH that the operation failed.
The LH will then invoke `hook_heap_informs_heap_of_block_request` on its parent
    if the invocation is successful, the resulting block is
        1. re-owned
        2. formatted
        3. moved to the appropriate LAL
    at which point the LAL is reinvoked with `hook_heap_informs_linkage_of_allocation_request`
        in this situation, the operation is guaranteed successful, and the result is returned.
otherwise, the LH will tell the invoker that the operation failed

    RRH hook_heap_informs_heap_of_block_request

The RRH will find the appropriately sized RRL and invoke `hook_heap_informs_linkage_of_block_request`.
The RRL will try to excise and return the head block.
    if the invocation is successful, the result is returned
otherwise the RRL will inform the RRH that the operation failed.
The RRH will then find its unsized RRL and invoke `hook_heap_informs_linkage_of_block_request`.
The RRL will try to excise and return the head block.
    if the invocation is successful, the result is returned
otherwise the RRL will inform the RRH that the operation failed.
The RRH will then invoke `hook_heap_informs_heap_of_block_request`
    if the invocation is successful, the resulting block is returned
    else the RRH informs the invoking heap that the operation failed

    GH hook_heap_informs_heap_of_block_request

The GH will create a Chunk, and give its immediate child 63 of the blocks.
The remaining block will be given to the invoker.
If Chunk creation is unsuccessful, then the GH informs the caller that the operation failed

    __vnza_dealloc

The Block header is found
The Block's deallocation method is invoked (`hook_client_informs_block_of_deallocation_request`)

====== IMPLEMENTATION NOTES ======
