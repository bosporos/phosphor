// -*- mode:c++ -*-

//
// project venice
// author Maximilien M. Cura
//

#ifndef __VNZ_ALLOC
#define __VNZ_ALLOC

#include <Venice/Compiler>
#include <Venice/Sys/Sync/Mutex>
#include <Venice/Sys/Thread/ID>

#include <stdint.h>
#include <stdio.h>

#define __VNZA_DEBUG

namespace vnz::alloc {
    enum IR {
        IR_OK,
        IR_FAIL,
    };

    enum BS : uint8_t {
        Active,
        Inactive,
    };

    enum BTTI : uint8_t {
        Bound,
        Unbound,
    };

    enum DBG_SIG : uint64_t {
        VNZA_DBG_SIGNAL_NONE                   = 0,
        VNZA_DBG_SIGNAL_DESTRUCTION_ORDER      = 1 << 0,
        VNZA_DBG_SIGNAL_ALLOCATION_BRANCHING   = 1 << 1,
        VNZA_DBG_SIGNAL_DEALLOCATION_BRANCHING = 1 << 2,
        VNZA_DBG_SIGNAL_CHUNK_LAYOUT           = 1 << 3,
        VNZA_DBG_SIGNAL_LINKAGE_CHANGES        = 1 << 4,
        VNZA_DBG_SIGNAL_BAD_DEALLOC            = 1 << 5,
    };
    extern DBG_SIG vnza_debug_state = VNZA_DBG_SIGNAL_NONE;

#define vnza_debug_println(fmt, ...) fprintf (stderr, fmt "\n", __VA_OPT__)

    struct __RespondsToStateChange;

    struct Block
    {
        void * range_begin;
        void * freeptr_local;
        void * freeptr_global;

        uint16_t object_size;
        uint16_t object_count;
        // Note: allocation_count will never underreport the number of available blocks.
        /* __atomic */ uint16_t allocation_count;
        // Note: activation_state MUST NOT be modified without globalfree_lock being
        // in a locked state (owned by the modifying thread) for the duration of
        // any modifications performed.
        /* __atomic */ BS activation_state;
        // whether or not it's locally thread-bound
        /* __atomic */ BTTI btti_state;

        // Note: state_change_responder MUST NOT be modified without globalfree_lock being
        // in a locked state (owned by the modifying thread) for the duration of
        // any modification performed.
        /* __atomic */ __RespondsToStateChange * state_change_responder;

        // MUST be updated whenever the Block moves to what could possibly be a
        // different thread.
        // Note: for RRLS, bound_thread_id does not matter--all threads shall be
        // treated as global deallocations.
        //
        // Because RRLS only contains Blocks from dead LHs, all Blocks will have
        // come from dead threads, and, thus, bound_thread_id should never pose
        // a problem.
        sys::thread::ID bound_thread_id;

        // Used for a lot of things.
        sys::sync::Mutex globalfree_lock;

        Block * left;
        Block * right;

        Block ();
        ~Block ();

        //! Will attempt to allocate a single object.
        //! On success, *object will be set, and IR_OK will be returned.
        //! On failure, *object's contents will be undefined, and IR_FAIL will be
        //! returned.
        //!
        //! If allocation succeeds, then the free pointer is updated, and allocation_count
        //! will be changed.
        IR hook_linkage_informs_block_of_allocation_request (void ** object);

        //! Will attempt to deallocate the given object.
        //! Will return IR_OK if the object is within the range of this Block,
        //! otherwise IR_FAIL will be returned.
        //!
        //! If deallocating the given object makes the Block empty (zeroes allocation_count)
        //! then hook_block_informs_linkage_of_empty_state() will be invoked on state_change_responder.
        IR hook_client_informs_block_of_deallocation_request (void * object);
        //! May only be used when the Block is empty and in an Inactive state.
        IR hook_linkage_informs_block_of_format_request (uint16_t size_to_format);

        IR hook_linkage_infomrs_block_of_thread_reassignment ();
        IR hook_linkage_informs_block_of_state_change (BS new_state);

        IR __local_alloc (void ** object);
    };

    struct __RespondsToStateChange
    {
        virtual IR hook_block_informs_linkage_of_empty_state (Block * invoker)        = 0;
        virtual IR hook_block_informs_linkage_of_empty_enough_state (Block * invoker) = 0;
    };

    struct __LinkageStoringBlocks
    {
        virtual IR hook_heap_informs_linkage_of_migrating_block (Block * migrating_block)       = 0;
        virtual IR hook_heap_informs_linkage_of_block_request (uint16_t o_size, Block ** block) = 0;
    };

    struct LH;

    struct LAL
        : public __RespondsToStateChange
    {
        /* __atomic */ Block * lal_active;
        sys::sync::Mutex lal_lock;
        LH * lal_parent;
        const uint16_t lal_osize;

        LAL (uint16_t os);
        ~LAL ();

        virtual IR hook_block_informs_linkage_of_empty_state (Block * invoker);
        virtual IR hook_block_informs_linkage_of_empty_enough_state (Block * invoker);
        IR hook_heap_informs_linkage_of_allocation_request (void ** object, LH * heap);
    };

    struct LRL
        : public __LinkageStoringBlocks
    {
        Block * lrl_head;
        sys::sync::Mutex lrl_lock;
        LH * lrl_parent;

        LRL ();
        ~LRL ();

        virtual IR hook_heap_informs_linkage_of_migrating_block (Block * migrating_block);
        virtual IR hook_heap_informs_linkage_of_block_request (uint16_t o_size, Block ** block);
    };

    struct RRLS
        : public __RespondsToStateChange,
          public __LinkageStoringBlocks
    {
        Block * rrls_head;
        sys::sync::Mutex rrls_lock;
        RH * rrls_parent;
        const uint16_t rrls_osize;

        RRLS (uint16_t os);
        ~RRLS ();

        virtual IR hook_heap_informs_linkage_of_migrating_block (Block * migrating_block);
        virtual IR hook_heap_informs_linkage_of_block_request (uint16_t o_size, Block ** block);
        virtual IR hook_block_informs_linkage_of_empty_state (Block * invoker);
        virtual IR hook_block_informs_linkage_of_empty_enough_state (Block * invoker);
    };

    struct RRLU
        : public __LinkageStoringBlocks
    {
        Block * rrlu_head;
        sys::sync::Mutex rrlu_lock;
        RH * rrlu_parent;

        RRLU ();
        ~RRLU ();

        virtual IR hook_heap_informs_linkage_of_migrating_block (Block * migrating_block);
        virtual IR hook_heap_informs_linkage_of_block_request (uint16_t o_size, Block ** block);
    };

    struct __ParentalHeapToLinkage
    {
        virtual IR hook_linkage_informs_heap_of_block_request (uint16_t o_size, Block ** block)          = 0;
        virtual IR hook_linkage_informs_heap_of_surplus_block (Block * surplus_block)                    = 0;
        virtual IR hook_linkage_informs_heap_of_evacuating_block_from_linkage (Block * evacuating_block) = 0;
    };

    struct __ParentalHeapToHeap
    {
        virtual IR hook_heap_informs_heap_of_block_request (uint16_t o_size, Block ** block) = 0;
        virtual IR hook_heap_informs_heap_of_surplus_block (Block * surplus_block)           = 0;
        virtual IR hook_heap_informs_heap_of_evacuating_block (Block * evacuating_block)     = 0;
        virtual IR hook_heap_informs_heap_of_dying_heap ()                                   = 0;
        virtual bool is_heap_possessing_of_parent ()                                         = 0;

        __ParentalHeapToHeap * heap_parent;
    };

    struct LH
        : public __ParentalHeapToLinkage
    {
        virtual IR hook_linkage_informs_heap_of_block_request (uint16_t o_size, Block ** block);
        virtual IR hook_linkage_informs_heap_of_surplus_block (Block * surplus_block);
        virtual IR hook_linkage_informs_heap_of_evacuating_block_from_linkage (Block * evacuating_block);
    };

    struct RH
        : public __ParentalHeapToLinkage,
          public __ParentalHeapToHeap
    {
        virtual IR hook_linkage_informs_heap_of_block_request (uint16_t o_size, Block ** block)          = 0;
        virtual IR hook_linkage_informs_heap_of_surplus_block (Block * surplus_block)                    = 0;
        virtual IR hook_linkage_informs_heap_of_evacuating_block_from_linkage (Block * evacuating_block) = 0;

        virtual IR hook_heap_informs_heap_of_block_request (uint16_t o_size, Block ** block) = 0;
        virtual IR hook_heap_informs_heap_of_surplus_block (Block * surplus_block)           = 0;
        virtual IR hook_heap_informs_heap_of_evacuating_block (Block * evacuating_block)     = 0;
        virtual IR hook_heap_informs_heap_of_dying_heap ()                                   = 0;
        virtual bool is_heap_possessing_of_parent ()                                         = 0;
    };

    struct GH
        : public __ParentalHeapToHeap
    {
        virtual IR hook_heap_informs_heap_of_block_request (uint16_t o_size, Block ** block) = 0;
        virtual IR hook_heap_informs_heap_of_surplus_block (Block * surplus_block)           = 0;
        virtual IR hook_heap_informs_heap_of_evacuating_block (Block * evacuating_block)     = 0;
        virtual IR hook_heap_informs_heap_of_dying_heap ()                                   = 0;
        virtual bool is_heap_possessing_of_parent ()                                         = 0;
    };
}

#endif /* !@__VNZ_ALLOC */
