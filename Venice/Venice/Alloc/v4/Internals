// -*- mode: c++ -*-

//
// project venice
// author Maximilien M. Cura
//

#ifndef __VNZ_ALLOC_INTERNALS
#define __VNZ_ALLOC_INTERNALS

#include <Venice/Compiler>
#include <Venice/Math/Integers>

namespace vnz::alloc::detail {
    template <typename T>
    struct Item
    {
        static Item<T> * alloc (T * x)
        {
            return new (malloc (sizeof (Item<T>))) Item (x);
        }
        static void free (Item<T> * x)
        {
            x.~Item ();
            return free (x);
        }

        T * inner;
        Item<T> *left, *right;

        Item (T * x)
            : inner { x }
            , left { nullptr }
            , right { nullptr }
        {}
        ~Item ()
        {}

        void excise ()
        {
            if (this->left != nullptr)
                this->left->right = this->right;
            if (this->right != nullptr)
                this->right->left = this->left;
        }

        void add_right (Item<T> * link)
        {
            link->right = this->right;
            if (link->right != nullptr)
                link->right->left = link;
            this->right = link;
            link->left  = this;
        }

        void add_left (Item<T> * link)
        {
            link->left = this->left;
            if (link->left != nullptr)
                link->left->right = link;
            this->left  = link;
            link->right = this;
        }

        Item<T> * find_left (T * obj)
        {
            Item<T> * current = this;
            while (current != nullptr && current->inner != obj)
                current = current->left;
            return current;
        }
        Item<T> * find_right (T * obj)
        {
            Item<T> * current = this;
            while (current != nullptr && current->inner != obj)
                current = current->right;
            return current;
        }
        Item<T> * find_left_right (T * obj)
        {
            Item<T> * result = this->find_left (obj);
            if (UNLIKELY (result == nullptr))
                return this->find_right (obj);
            return result;
        }
        Item<T> * find_right_left (T * obj)
        {
            Item<T> * result = this->find_right (obj);
            if (UNLIKELY (result == nullptr))
                return this->find_left (obj);
            return result;
        }
    };

    ALWAYS_INLINE math::_u16 * af (void * x)
    {
        return static_cast<math::_u16 *> (x);
    }
    ALWAYS_INLINE math::_u16 * a8 (void * x)
    {
        return static_cast<math::_u8 *> (x);
    }
}

#endif /* !@__VNZ_ALLOC_INTERNALS */
