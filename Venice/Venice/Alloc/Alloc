// -*- mode: c++ -*-

//
// project venice
// author Maximilien M. Cura
//

#ifndef __VNZ_ALLOC
#define __VNZ_ALLOC

#include <venice/Compiler>
#include <venice/math/Integers>
#include <venice/sys/thread/ID>
#include <venice/sys/sync/Mutex>
// #include <venice/sys/sync/RwLock>
#include <venice/atomic/Atomic>
#include <venice/Alloc/Internals>

#define __VNZA_PADDING_BYTES(n)                    \
    union {                                        \
        const math::_u8 __padding##__COUNTER__[n]; \
    };

namespace vnz::alloc {
    struct ActiveBlockLinkage;

    struct Block
    {
        void * range_begin;
        void * freeptr_local;
        /* __atomic */ void * freeptr_global;

        math::_u16 object_size;
        math::_u16 object_count;
        math::_u16 _allocation_count;
        atomic::Atomic<math::_u16> allocation_count;

        sys::thread::ID local_thread_id;

        void (*_shadow_free) (Block *);

        /* __atomic */ ActiveBlockLinkage * active_linkage;

        Block (void * memory = nullptr, void (*shadow_free) (Block *) = nullptr);
        ~Block ();

        // rebind local_thread_id and re-point the linkage pointer
        void hook_informs_block_of_owner_change (ActiveBlockLinkage * new_linkage);

        void * hook_linkage_informs_block_of_allocation_request ();
        void * hook_block_informs_block_of_local_list_allocation_request ();
        void hook_informs_block_of_deallocation_request (void * object_to_deallocate);

        void hook_block_informs_block_of_emptiness ();
        void hook_block_informs_block_of_sufficient_emptiness ();

        void hook_informs_block_of_memory_range_assignment (void * new_memory, void (*_new_shadow_free) (Block *) = nullptr);
        void hook_informs_block_of_format_request (math::_u16 const new_object_size);
    };

    struct Metric;

    // Allocation-side logic

    struct ActiveBlockLinkage
    {
        Metric * metric;
        /* __atomic */ detail::Item<Block> * linkage_head;

        ActiveBlockLinkage (Metric * metric);

        virtual void hook_block_informs_linkage_of_empty_block (Block * informer)
            = 0;
        virtual void hook_block_informs_linkage_of_sufficiently_empty_block (Block * informer) = 0;
        virtual void hook_informs_linkage_of_block_addition (Block * new_block)                = 0;
    };

    struct LocalHeap;

    struct ActiveLocalLinkage
        : public ActiveBlockLinkage
    {
        // note; linkage_head is to be atomically read/written
        // however, atomicity only applies to linkage_head->inner here
        // this is because Block::hook_informs_block_of_deallocation_request needs
        // to be able to check if it is a head block or not
        sys::sync::Mutex linkage_lock;
        atomic::Atomic<math::_u64> count_of_empty_blocks;
        const math::_u16 object_size;
        __VNZA_PADDING_BYTES (6)
        LocalHeap * heap;

        ActiveLocalLinkage (math::_u16 const obj_sz, LocalHeap * heap_to_use, Metric * metric_to_use);
        ~ActiveLocalLinkage ();

        virtual void hook_block_informs_linkage_of_empty_block (Block * informer);
        virtual void hook_block_informs_linkage_of_sufficiently_empty_block (Block * informer);
        virtual void hook_informs_linkage_of_block_addition (Block * new_block);

        void hook_heap_informs_linkage_of_allocation_request ();
    };

    struct ActiveRegionalLinkage
        : public ActiveBlockLinkage
    {
        sys::sync::Mutex linkage_lock;
        atomic::Atomic<math::_u64> count_of_blocks;
        const math::_u16 object_size;
        __VNZA_PADDING_BYTES (6)
        RegionalHeap * heap;

        // if sized, then we need to call Heap.hook_linkage_informs_heap_of_empty_block
        virtual void hook_block_informs_linkage_of_empty_block (Block * informer);
        // if sized, then nothing happens
        virtual void hook_block_informs_linkage_of_sufficiently_empty_block (Block * informer);
        virtual void hook_informs_linkage_of_block_addition (Block * new_block);
        // will either keep it or pass it further up the chain
        void hook_heap_informs_linkage_of_propagating_block (Block * informer);
        // heap is asking for a Block of the type stored by
        Block * hook_heap_informs_linkage_of_block_request ();
    };

    struct Heap
    {
        Metric * metric;

        Heap (Metric * metric_to_use);

        virtual void hook_linkage_informs_heap_of_empty_block (Block * block)       = 0;
        virtual void hook_linkage_informs_heap_of_propagating_block (Block * block) = 0;
    };

    struct LocalHeap
        : public Heap
    {
        Heap * parent_heap;

        LocalHeap ();
        ~LocalHeap ();

        virtual void hook_linkage_informs_heap_of_empty_block (Block * block);
        virtual void hook_linkage_informs_heap_of_propagating_block (Block * block);
        void * hook_thread_informs_heap_of_allocation_request ();
    };

    struct Metric
    {
        math::_u16 metric_block_sufficient_emptiness (Block * block);
    };

}

#endif /* !@__VNZ_ALLOC */
