// -*- mode: c++ -*-

//
// project venice
// author Maximilien M. Cura
//

#ifndef __VNZ_ALLOC
#define __VNZ_ALLOC

#include <Venice/Compiler>
#include <Venice/Math/Integers>
#include <Venice/Sys/Sync/Mutex>
#include <Venice/Sys/Thread/ID>
#include <Venice/Atomic/Atomic>

namespace vnz::alloc {
    enum InvocationResult {
        IR_OK,
        IR_FAIL,
    };

    enum BlockState : math::_u8 {
        Active,
        Inactive,
    };

    typedef math::_u16 OSize;
    typedef math::_u16 OCount;

    struct RL__EEState_EState;

    struct Block
    {
        // +0 +8
        void * range_begin;
        // +8 + 8
        void * freeptr_local;
        // +16 +8
        void * freeptr_global;

        // +24 +2
        OSize object_size;
        // +26 +2
        OCount object_count;
        // +28 +2
        /* __atomic */ OCount allocation_count;
        // +30 +1
        /* __atomic */ BlockState block_state;
        // +31 +1
        UNUSED math::_u8 __padding1;

        // +32 +8
        RL__EEState_EState * state_change_responder;

        // +40 +8
        sys::thread::ID bound_thread_id;
        // +48 +64
        sys::sync::Mutex globalfree_lock;
        // +112 +8
        Block * l_left;
        // +120 +8 -> 128
        Block * l_right;

        Block ();
        ~Block ();

        InvocationResult hook_linkage_informs_block_of_allocation_request (void ** object);
        InvocationResult hook_client_informs_block_of_deallocation_request (void * object);
        InvocationResult hook_linkage_informs_block_of_format_request (OSize size_to_format);
        InvocationResult hook_linkage_informs_block_of_reassignment ();

        InvocationResult __local_alloc (void ** object);
    };

    struct RL__EEState_EState
    {
        virtual InvocationResult hook_block_informs_linkage_of_empty_state (Block * invoker)        = 0;
        virtual InvocationResult hook_block_informs_linkage_of_empty_enough_state (Block * invoker) = 0;
    };

    struct RL__BlockCache
    {
        virtual InvocationResult hook_heap_informs_linkage_of_block_request (OSize size, Block ** block) = 0;
        virtual InvocationResult hook_heap_informs_linkage_of_migrating_block (Block * block)            = 0;
    };

    struct RH__Hierarchical
    {
        RH__Hierarchical * rhh_parent;
    };

    struct RL__Hierarchical
    {
        RH__Hierarchical * rlh_heap;
    };

    // template <class T>
    // struct Item
    // {
    //     T * inner;
    //     Item<T> * left;
    //     Item<T> * right;
    // };

    struct LH;

    struct LAL
        : public RL__EEState_EState,
          public RL__Hierarchical
    {
        OSize lal_osize;
        UNUSED math::_u16 __padding1[3];
        /* dll bi; search only sll. remove,add only dll */
        /* dll bi-headwise wise __atomic */
        /* __atomic */ Block * lal_active;
        sys::sync::Mutex lal_lock;

        LAL ();
        ~LAL ();

        virtual InvocationResult hook_block_informs_linkage_of_empty_state (Block * invoker);
        virtual InvocationResult hook_block_informs_linkage_of_empty_enough_state (Block * invoker);
        InvocationResult hook_heap_informs_linkage_of_allocation_request (void ** object, LH * heap);
    };

#define __VNZA_LRL_CAP 4

    struct LRL
        : public RL__BlockCache,
          public RL__Hierarchical
    {
        /* sll right */
        Block * lrl_head;
        /* __atomic */ math::_usize lrl_length;
        sys::sync::Mutex lrl_lock;

        LRL ();
        ~LRL ();

        virtual InvocationResult hook_heap_informs_linkage_of_block_request (OSize size, Block ** block);
        virtual InvocationResult hook_heap_informs_linkage_of_migrating_block (Block * block);
    };

#define __VNZA_RRLS_CAP 4

    // might have to split this
    struct RRLS
        : public RL__EEState_EState,
          public RL__BlockCache,
          public RL__Hierarchical
    {
        Block * rrls_head;
        /* __atomic */ math::_usize rrls_length;
        sys::sync::Mutex rrls_lock;

        RRLS ();
        ~RRLS ();

        virtual InvocationResult hook_heap_informs_linkage_of_block_request (OSize size, Block ** block);
        virtual InvocationResult hook_heap_informs_linkage_of_migrating_block (Block * block);
        virtual InvocationResult hook_block_informs_linkage_of_empty_state (Block * invoker);
        virtual InvocationResult hook_block_informs_linkage_of_empty_enough_state (Block * invoker);
    };

#define __VNZA_RRLU_CAP 8

    struct RRLU
        : public RL__BlockCache,
          public RL__Hierarchical
    {
        Block * rrlu_head;
        /* __atomic */ math::_usize rrlu_length;
        sys::sync::Mutex rrlu_lock;

        RRLU ();
        ~RRLU ();

        virtual InvocationResult hook_heap_informs_linkage_of_block_request (OSize size, Block ** block);
        virtual InvocationResult hook_heap_informs_linkage_of_migrating_block (Block * block);
    };

    struct RH__LPropagator
    {
        virtual InvocationResult hook_linkage_informs_heap_of_surplus_block (Block * block)    = 0;
        virtual InvocationResult hook_linkage_informs_heap_of_evacuating_block (Block * block) = 0;
    };

    struct RH__HPropagator
    {
        virtual InvocationResult hook_heap_informs_heap_of_surplus_block (Block * block)    = 0;
        virtual InvocationResult hook_heap_informs_heap_of_evacuating_block (Block * block) = 0;
    };

    struct RH__HBlockRequest
    {
        virtual InvocationResult hook_heap_informs_heap_of_block_request (OSize os, Block ** block) = 0;
    };

    struct RH__LBlockRequest
    {
        virtual InvocationResult hook_linkage_informs_heap_of_block_request (OSize os, Block ** block) = 0;
    };

    struct RH__Parent
    {
        virtual InvocationResult hook_heap_informs_heap_of_heap_death () = 0;
    };

#define __VNZA_SL_NUMBER 0x18

    struct LH
        : public RH__LPropagator,
          public RH__LBlockRequest,
          public RH__Hierarchical
    {
        LAL lal_table[__VNZA_SL_NUMBER];
        LRL lrl;

        LH ();
        ~LH ();

        virtual InvocationResult hook_linkage_informs_heap_of_surplus_block (Block * block);
        virtual InvocationResult hook_linkage_informs_heap_of_evacuating_block (Block * block);
        virtual InvocationResult hook_linkage_informs_heap_of_block_request (OSize os, Block ** block);

        InvocationResult hook_client_informs_heap_of_allocation_request (OSize os, void ** object);
    };

    struct RH
        : public RH__LPropagator,
          public RH__HPropagator,
          public RH__HBlockRequest,
          public RH__Hierarchical,
          public RH__Parent
    {
        RRLS rrls_table[__VNZA_SL_NUMBER];
        RRLU rrlu;
        /* __atomic */ math::_usize rh_active_references;

        RH ();
        ~RH ();

        virtual InvocationResult hook_linkage_informs_heap_of_surplus_block (Block * block);
        virtual InvocationResult hook_linkage_informs_heap_of_evacuating_block (Block * block);
        virtual InvocationResult hook_heap_informs_heap_of_surplus_block (Block * block);
        virtual InvocationResult hook_heap_informs_heap_of_evacuating_block (Block * block);
        virtual InvocationResult hook_heap_informs_heap_of_block_request (OSize os, Block ** block);
        virtual InvocationResult hook_heap_informs_heap_of_heap_death ();

        InvocationResult __evacuate_from_child (Block * block);
        InvocationResult __process_surplus_from_child (Block * block);
    };

    struct GH
        : public RH__HBlockRequest,
          public RH__HPropagator,
          public RH__Parent
    {
        /* __atomic */ math::_u64 gh_stat_chunks;
        void * gh_chunklist;
        sys::sync::Mutex gh_chunklist_lock;
        RH * gh_tributary;

        GH ();
        ~GH ();

        virtual InvocationResult hook_heap_informs_heap_of_block_request (OSize os, Block ** block);
        virtual InvocationResult hook_heap_informs_heap_of_heap_death ();
        virtual InvocationResult hook_heap_informs_heap_of_surplus_block (Block * block);
        virtual InvocationResult hook_heap_informs_heap_of_evacuating_block (Block * block);
    };
}

#endif /* !@__VNZ_ALLOC */
