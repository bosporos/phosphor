// -*- mode:c++ -*-

//
// project pewter
// author Maximilien M. Cura
//

#ifndef __PEWTER_DISPLAY_BUFFER
#define __PEWTER_DISPLAY_BUFFER

#include <Venice/Math/Integers>
#include <Pewter/Glyph>
#include <Pewter/Math/Geometry>
#include <Pewter/Display/Display>

namespace pewter::display {
    struct Buffer
    {
        Glyph * glyph_buffer           = nullptr;
        vnz::math::_u64 * dirty_buffer = nullptr;
        vnz::math::_u64 * mask_buffer  = nullptr;
        // TODO: transparency_effect_buffer
        // Color * transparency_effect_buffer = nullptr;

        math::Rect<DisplayCoordinate> bounding_box;

        bool buffer_is_allocated = false;
        bool buffer_has_deltas   = false;
        // +6
        vnz::math::_u8 __padding0[6];

        Buffer ();
        ~Buffer ();

        void allocate_buffers (math::Rect<DisplayCoordinate> _bbox);

        void mask (math::Rect<DisplayCoordinate> box, bool value);
        void mask (math::Point<DisplayCoordinate> point, bool value);
        void mask_all (bool value);

        void dirty (math::Rect<DisplayCoordinate> box, bool value);
        void dirty (math::Point<DisplayCoordinate> point, bool value);
        void dirty_all (bool value);

        ALWAYS_INLINE void set (math::Point<DisplayCoordinate> p, Glyph glyph)
        {
            set (p.x, p.y, glyph);
        }

        ALWAYS_INLINE void set (DisplayCoordinate x, DisplayCoordinate y, Glyph glyph)
        {
            glyph_buffer[x + y * bounding_box.size.x] = glyph;
        }

        ALWAYS_INLINE Glyph & get (math::Point<DisplayCoordinate> p)
        {
            return get (p.x, p.y);
        }

        ALWAYS_INLINE Glyph & get (DisplayCoordinate x, DisplayCoordinate y)
        {
            return glyph_buffer[x + y * bounding_box.size.x];
        }

        // void place (Glyph * sequence, vnz::math::_usize length);
        void undirty ();
    };
}

#endif /* !@__PEWTER_DISPLAY_BUFFER */
